<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FamilyDex Arena</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0d111a;
      --panel: #141a26;
      --card: #182133;
      --primary: #5fd4ff;
      --accent-psychic: #d47dff;
      --accent-electric: #fdd835;
      --accent-fairy: #ff9fd6;
      --accent-sound: #8ee0ff;
      --accent-guardian: #8de1af;
      --accent-steel: #9ea7b8;
      --accent-mind: #b1c0ff;
      --accent-normal: #d7d7d7;
      --text: #e8f1ff;
      --muted: #9fb3c8;
      --success: #76e4b0;
      --danger: #ff7b7b;
      --shadow: 0 14px 45px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(93, 80, 188, 0.15), transparent 30%),
                  radial-gradient(circle at 80% 0%, rgba(95, 212, 255, 0.2), transparent 28%),
                  linear-gradient(135deg, #0c1220, #0b0f19 50%, #0f1222);
      color: var(--text);
      min-height: 100vh;
      padding: 16px;
    }
    h1, h2, h3, h4 { margin: 0; }
    .app {
      max-width: 1280px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .topbar {
      background: linear-gradient(120deg, rgba(95, 212, 255, 0.2), rgba(212, 125, 255, 0.15));
      border: 1px solid rgba(255,255,255,0.05);
      padding: 16px 20px;
      border-radius: 20px;
      box-shadow: var(--shadow);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .title {
      font-size: 26px;
      font-weight: 700;
      letter-spacing: 0.6px;
    }
    .subtitle { color: var(--muted); font-weight: 500; }
    .layout {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 16px;
    }
    .panel {
      background: var(--panel);
      border-radius: 20px;
      padding: 16px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,0.04);
    }
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }
    .card {
      background: var(--card);
      padding: 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.05);
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      transition: transform 0.2s ease, box-shadow 0.2s ease, border 0.2s;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 14px 32px rgba(0,0,0,0.26);
      border-color: rgba(255,255,255,0.1);
    }
    .card.active { border: 1px solid var(--primary); box-shadow: 0 14px 32px rgba(95, 212, 255, 0.22); }
    .mon-name { font-weight: 700; font-size: 18px; margin-bottom: 4px; }
    .mon-desc { color: var(--muted); font-size: 13px; }
    .types { display: flex; gap: 6px; margin: 10px 0; flex-wrap: wrap; }
    .type-chip {
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      color: #0c0f18;
      text-shadow: 0 1px 0 rgba(255,255,255,0.45);
    }
    .stats { margin: 8px 0; }
    .stat-row { display: grid; grid-template-columns: 60px 1fr 38px; align-items: center; margin-bottom: 4px; gap: 6px; }
    .stat-name { font-size: 12px; color: var(--muted); }
    .stat-bar {
      background: rgba(255,255,255,0.08);
      height: 8px;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
    }
    .stat-fill { height: 100%; border-radius: 12px; background: linear-gradient(90deg, rgba(95, 212, 255, 0.9), rgba(212, 125, 255, 0.8)); width: 50%; }
    .stat-val { font-size: 12px; color: var(--muted); text-align: right; }
    .card-actions { display: flex; gap: 8px; margin-top: 10px; }
    button {
      border: none;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(120deg, rgba(95, 212, 255, 0.12), rgba(212, 125, 255, 0.12));
      color: var(--text);
      transition: transform 0.15s ease, box-shadow 0.2s ease, filter 0.2s;
    }
    button:hover { transform: translateY(-1px) scale(1.01); box-shadow: 0 10px 22px rgba(0,0,0,0.25); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .primary { background: linear-gradient(120deg, #5fd4ff, #d47dff); color: #0c0f18; }
    .secondary { background: rgba(255,255,255,0.08); }
    .info-panel {
      margin-top: 12px;
      padding: 12px;
      background: rgba(0,0,0,0.25);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.04);
    }
    .info-title { font-weight: 700; margin-bottom: 6px; }
    .move-list { display: grid; gap: 6px; margin-top: 6px; }
    .move-item { background: rgba(255,255,255,0.03); padding: 8px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.05); }
    .move-name { font-weight: 600; }
    .move-desc { color: var(--muted); font-size: 13px; }

    .battle {
      display: grid;
      grid-template-rows: auto auto 1fr;
      gap: 12px;
    }
    .battlefield {
      background: radial-gradient(circle at 30% 30%, rgba(95, 212, 255, 0.12), transparent 40%),
                  radial-gradient(circle at 70% 70%, rgba(212, 125, 255, 0.12), transparent 40%),
                  #111728;
      border-radius: 18px;
      padding: 16px;
      border: 1px solid rgba(255,255,255,0.04);
      min-height: 220px;
      position: relative;
      overflow: hidden;
    }
    .battle-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .unit {
      background: rgba(0,0,0,0.25);
      border-radius: 14px;
      padding: 12px;
      width: 48%;
      border: 1px solid rgba(255,255,255,0.05);
      position: relative;
    }
    .unit .label { color: var(--muted); font-size: 12px; }
    .hpbar {
      height: 12px;
      background: rgba(255,255,255,0.08);
      border-radius: 12px;
      overflow: hidden;
      margin-top: 6px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .hpfill { height: 100%; width: 100%; background: linear-gradient(90deg, #76e4b0, #5fd4ff); transition: width 0.4s ease; }
    .unit-name { font-weight: 700; font-size: 16px; margin-top: 6px; }
    .status-text { color: var(--muted); font-size: 12px; margin-top: 2px; min-height: 16px; }
    .vs { font-weight: 700; color: var(--muted); }
    .moves { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; }
    .move-btn { text-align: left; position: relative; overflow: hidden; }
    .move-btn span { display: block; font-size: 13px; color: #0c0f18; }

    .action-log {
      background: var(--panel);
      border-radius: 16px;
      padding: 12px;
      height: 180px;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.05);
      box-shadow: var(--shadow);
    }
    .log-line { font-size: 13px; margin-bottom: 6px; color: var(--muted); }
    .winner-banner {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(12,15,24,0.85), rgba(12,15,24,0.65));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 800;
      letter-spacing: 1px;
      color: var(--text);
      text-align: center;
    }
    .attack-anim { animation: strike 0.35s ease; }
    .hit-anim { animation: hit 0.35s ease; }
    @keyframes strike {
      0% { transform: translateX(0); opacity: 1; }
      40% { transform: translateX(8px); opacity: 0.8; }
      100% { transform: translateX(0); opacity: 1; }
    }
    @keyframes hit {
      0% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      50% { transform: translateX(4px); }
      75% { transform: translateX(-2px); }
      100% { transform: translateX(0); }
    }
    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
      .unit { width: 100%; }
      .battle-row { flex-direction: column; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div>
        <div class="title">FamilyDex Arena</div>
        <div class="subtitle">A pocket arena for the family’s legendary forms</div>
      </div>
      <div class="subtitle">Keyboard shortcuts: 1-4 to use moves</div>
    </div>

    <div class="layout">
      <div class="panel" id="dex-panel">
        <div class="panel-header">
          <h3>FamilyDex</h3>
          <small class="subtitle">Select contenders</small>
        </div>
        <div class="cards" id="card-container"></div>
        <div class="info-panel" id="info-panel">
          <div class="info-title">Tap a FamilyMon to view details</div>
          <div class="info-content subtitle">Stats, moves, and passives will appear here.</div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <h3>Battle Arena</h3>
          <div>
            <button class="secondary" id="start-btn" disabled>Start Battle</button>
          </div>
        </div>
        <div class="battle">
          <div class="battlefield" id="battlefield">
            <div class="battle-row">
              <div class="unit" id="player-unit">
                <div class="label">Player</div>
                <div class="unit-name" id="player-name">---</div>
                <div class="types" id="player-types"></div>
                <div class="hpbar"><div class="hpfill" id="player-hp" style="width:0%"></div></div>
                <div class="status-text" id="player-status">Select a FamilyMon</div>
              </div>
              <div class="vs">VS</div>
              <div class="unit" id="opponent-unit">
                <div class="label">Opponent</div>
                <div class="unit-name" id="opponent-name">---</div>
                <div class="types" id="opponent-types"></div>
                <div class="hpbar"><div class="hpfill" id="opponent-hp" style="width:0%"></div></div>
                <div class="status-text" id="opponent-status">Select an opponent</div>
              </div>
            </div>
            <div class="winner-banner" id="winner-banner" style="display:none;"></div>
          </div>
          <div class="moves" id="move-buttons"></div>
          <div class="action-log" id="log"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== Data: FamilyMon definitions =====
    const familyMon = [
      {
        id: 'oliver',
        name: 'OliverMon',
        description: 'Ultra-strategist; bends maths, quantum, and code to his will.',
        types: ['PSYCHIC', 'ELECTRIC'],
        stats: { hp: 120, atk: 70, def: 60, spd: 95, int: 120, focus: 90 },
        passive: { name: 'Hyperfocus', description: 'When HP falls below 50% for the first time, INT and SPD rise sharply.' },
        moves: [
          { name: 'Quantum Cascade', type: 'PSYCHIC', power: 40, description: 'INT-heavy strike that warps probability.', effect: 'int_scaled' },
          { name: 'Code Injection', type: 'ELECTRIC', power: 28, description: 'Damages and leaves systems exposed (Vulnerability).', effect: 'vulnerability' },
          { name: 'Infinite Series', type: 'PSYCHIC', power: 18, description: 'Three rapid hits with a chance to pierce defenses.', effect: 'multi' },
          { name: 'Logic Net', type: 'ELECTRIC', power: 24, description: 'Traps target, lowering their SPD briefly.', effect: 'slow' },
        ]
      },
      {
        id: 'grace',
        name: 'GraceMon',
        description: 'Creative resonance, vivid sketches, and harmonic vibes.',
        types: ['FAIRY', 'SOUND'],
        stats: { hp: 110, atk: 60, def: 65, spd: 90, int: 115, focus: 85 },
        passive: { name: 'Artistic Aura', description: 'Allies gain a slight INT boost while she performs.' },
        moves: [
          { name: 'Chromatic Burst', type: 'FAIRY', power: 34, description: 'Prismatic blast; may inspire self for extra INT.', effect: 'inspire' },
          { name: 'Echo Sketch', type: 'SOUND', power: 26, description: 'Copies last enemy move with a small boost.', effect: 'copy' },
          { name: 'Harmony Shield', type: 'SOUND', power: 0, description: 'Sound barrier reducing incoming damage for a turn.', effect: 'shield' },
          { name: 'Palette Pulse', type: 'FAIRY', power: 24, description: 'Soft pulse that calms foes, slightly lowering ATK.', effect: 'soften' },
        ]
      },
      {
        id: 'sophia',
        name: 'SophiaMon',
        description: 'Organiser and guardian; keeps everyone composed and protected.',
        types: ['NORMAL', 'GUARDIAN'],
        stats: { hp: 125, atk: 55, def: 85, spd: 80, int: 95, focus: 75 },
        passive: { name: 'Anchor of the House', description: 'Starts battle granting allies extra DEF.' },
        moves: [
          { name: 'Family Shield', type: 'GUARDIAN', power: 0, description: 'Raises defenses significantly this turn.', effect: 'team_shield' },
          { name: 'Schedule Sync', type: 'NORMAL', power: 0, description: 'Heals both and speeds up rhythm.', effect: 'heal_speed' },
          { name: 'Calm Presence', type: 'GUARDIAN', power: 0, description: 'Cleanses debuffs and grants resilience.', effect: 'cleanse' },
          { name: 'Steady Strike', type: 'NORMAL', power: 26, description: 'Simple, reliable hit boosted by focus.', effect: 'steady' },
        ]
      },
      {
        id: 'endrit',
        name: 'EndritMon',
        description: 'Top-tier counsel; logical pressure and courtroom authority.',
        types: ['STEEL', 'MIND'],
        stats: { hp: 118, atk: 80, def: 80, spd: 88, int: 105, focus: 88 },
        passive: { name: 'Case Won', description: 'Upon defeating a foe, restores a portion of HP.' },
        moves: [
          { name: 'Cross-Examination', type: 'MIND', power: 32, description: 'Extra power if enemy just acted.', effect: 'reactive' },
          { name: 'Chambers Verdict', type: 'STEEL', power: 38, description: 'High authority strike with a chance to Silence.', effect: 'silence' },
          { name: 'Closing Statement', type: 'MIND', power: 30, description: 'Solid damage while boosting INT.', effect: 'self_int' },
          { name: 'Precedent Push', type: 'STEEL', power: 24, description: 'Pressure move reducing enemy DEF slightly.', effect: 'armor_break' },
        ]
      }
    ];

    // ===== Type color helper =====
    const typeColors = {
      PSYCHIC: 'var(--accent-psychic)',
      ELECTRIC: 'var(--accent-electric)',
      FAIRY: 'var(--accent-fairy)',
      SOUND: 'var(--accent-sound)',
      GUARDIAN: 'var(--accent-guardian)',
      STEEL: 'var(--accent-steel)',
      MIND: 'var(--accent-mind)',
      NORMAL: 'var(--accent-normal)'
    };

    // ===== Type effectiveness chart =====
    const typeChart = {
      PSYCHIC: { MIND: 0.8, STEEL: 0.9 },
      ELECTRIC: { SOUND: 1.2, WATER: 1.1 },
      FAIRY: { STEEL: 0.8, MIND: 1.1 },
      SOUND: { PSYCHIC: 1.1, ELECTRIC: 0.9 },
      GUARDIAN: { STEEL: 0.9, FAIRY: 1.05 },
      STEEL: { FAIRY: 1.2, SOUND: 0.95 },
      MIND: { PSYCHIC: 0.9, NORMAL: 1.05 },
      NORMAL: { STEEL: 0.9 }
    };

    // ===== State =====
    let selectedPlayer = null;
    let selectedOpponent = null;
    let battleState = null;
    let lastEnemyMove = null;

    const cardContainer = document.getElementById('card-container');
    const infoPanel = document.getElementById('info-panel');
    const moveButtons = document.getElementById('move-buttons');
    const startBtn = document.getElementById('start-btn');
    const logEl = document.getElementById('log');
    const playerName = document.getElementById('player-name');
    const opponentName = document.getElementById('opponent-name');
    const playerTypes = document.getElementById('player-types');
    const opponentTypes = document.getElementById('opponent-types');
    const playerHP = document.getElementById('player-hp');
    const opponentHP = document.getElementById('opponent-hp');
    const playerStatus = document.getElementById('player-status');
    const opponentStatus = document.getElementById('opponent-status');
    const winnerBanner = document.getElementById('winner-banner');

    // ===== Utility Functions =====
    function createTypeChip(type) {
      const div = document.createElement('div');
      div.className = 'type-chip';
      div.style.background = typeColors[type] || 'var(--primary)';
      div.textContent = type;
      return div;
    }

    function log(message) {
      const line = document.createElement('div');
      line.className = 'log-line';
      line.textContent = message;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function renderCards() {
      cardContainer.innerHTML = '';
      familyMon.forEach(mon => {
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.id = mon.id;
        card.innerHTML = `
          <div class="mon-name">${mon.name}</div>
          <div class="mon-desc">${mon.description}</div>
          <div class="types">${mon.types.map(t => `<span class="type-chip" style="background:${typeColors[t] || 'var(--primary)'}">${t}</span>`).join('')}</div>
          <div class="stats">
            ${Object.entries(mon.stats).map(([key,val]) => {
              const cap = 150;
              return `<div class='stat-row'>
                <div class='stat-name'>${key.toUpperCase()}</div>
                <div class='stat-bar'><div class='stat-fill' style='width:${Math.min(100, (val/cap)*100)}%'></div></div>
                <div class='stat-val'>${val}</div>
              </div>`;
            }).join('')}
          </div>
          <div class="card-actions">
            <button class="secondary select-player">Player</button>
            <button class="secondary select-opponent">Opponent</button>
          </div>
        `;
        card.addEventListener('click', (e) => {
          if (e.target.classList.contains('select-player') || e.target.classList.contains('select-opponent')) return;
          highlightCard(mon.id);
          showInfo(mon);
        });
        card.querySelector('.select-player').addEventListener('click', (e) => {
          e.stopPropagation();
          selectedPlayer = mon;
          highlightCard(mon.id);
          showInfo(mon);
          updateSelections();
        });
        card.querySelector('.select-opponent').addEventListener('click', (e) => {
          e.stopPropagation();
          selectedOpponent = mon;
          highlightCard(mon.id);
          showInfo(mon);
          updateSelections();
        });
        cardContainer.appendChild(card);
      });
    }

    function highlightCard(id) {
      document.querySelectorAll('.card').forEach(c => c.classList.toggle('active', c.dataset.id === id));
    }

    function showInfo(mon) {
      infoPanel.innerHTML = `
        <div class="info-title">${mon.name}</div>
        <div class="subtitle">Types: ${mon.types.join(' / ')}</div>
        <div class="subtitle">Passive: <strong>${mon.passive.name}</strong> – ${mon.passive.description}</div>
        <div class="move-list">
          ${mon.moves.map(m => `
            <div class="move-item">
              <div class="move-name">${m.name} <span class="type-chip" style="background:${typeColors[m.type] || 'var(--primary)'}">${m.type}</span></div>
              <div class="move-desc">Power ${m.power} – ${m.description}</div>
            </div>`).join('')}
        </div>
      `;
    }

    function updateSelections() {
      startBtn.disabled = !(selectedPlayer && selectedOpponent);
      playerName.textContent = selectedPlayer ? selectedPlayer.name : '---';
      opponentName.textContent = selectedOpponent ? selectedOpponent.name : '---';
      renderTypeRow(playerTypes, selectedPlayer?.types);
      renderTypeRow(opponentTypes, selectedOpponent?.types);
      playerStatus.textContent = selectedPlayer ? 'Ready' : 'Select a FamilyMon';
      opponentStatus.textContent = selectedOpponent ? 'Ready' : 'Select an opponent';
    }

    function renderTypeRow(el, types) {
      el.innerHTML = '';
      if (!types) return;
      types.forEach(t => el.appendChild(createTypeChip(t)));
    }

    function resetBattleState() {
      if (!selectedPlayer || !selectedOpponent) return;
      battleState = {
        active: true,
        player: { ...selectedPlayer, currentHP: selectedPlayer.stats.hp, buffs: {}, debuffs: {}, hyper: false, shield: 0 },
        opponent: { ...selectedOpponent, currentHP: selectedOpponent.stats.hp, buffs: {}, debuffs: {}, hyper: false, shield: 0 },
        turn: 'player',
      };
      lastEnemyMove = null;
      winnerBanner.style.display = 'none';
      logEl.innerHTML = '';
      applyStartPassives();
      updateUI();
      log('Battle started!');
    }

    // ===== Passives =====
    function applyStartPassives() {
      if (battleState.player.id === 'sophia') {
        battleState.player.buffs.def = (battleState.player.buffs.def || 0) + 10;
        battleState.opponent.buffs.def = (battleState.opponent.buffs.def || 0) + 5;
        log('SophiaMon anchors the house: team DEF rises.');
      }
    }

    function checkHyperfocus(unit, isPlayer) {
      if (unit.id === 'oliver' && !unit.hyper && unit.currentHP <= unit.stats.hp * 0.5) {
        unit.hyper = true;
        unit.buffs.int = (unit.buffs.int || 0) + 20;
        unit.buffs.spd = (unit.buffs.spd || 0) + 20;
        log(`${unit.name}'s Hyperfocus ignites! INT and SPD surged.`);
      }
    }

    function applyArtisticAura(attacker) {
      return attacker.id === 'grace' ? 1.08 : 1;
    }

    function applyCaseWon(attacker) {
      if (attacker.id === 'endrit') {
        const heal = Math.floor(attacker.stats.hp * 0.15);
        attacker.currentHP = Math.min(attacker.stats.hp, attacker.currentHP + heal);
        log(`${attacker.name}'s Case Won restores ${heal} HP!`);
      }
    }

    // ===== Battle Calculations =====
    function typeEffectiveness(moveType, targetTypes) {
      let modifier = 1;
      targetTypes.forEach(t => {
        if (typeChart[moveType] && typeChart[moveType][t]) modifier *= typeChart[moveType][t];
      });
      return modifier;
    }

    function computeDamage(attacker, defender, move) {
      const atk = attacker.stats.atk + (attacker.buffs.atk || 0);
      const intStat = (attacker.stats.int + (attacker.buffs.int || 0)) * applyArtisticAura(attacker);
      const def = defender.stats.def + (defender.buffs.def || 0) - (defender.debuffs.def || 0);
      const base = (move.power + atk / 4 + intStat / 6) - (def / 5) + (Math.random() * 6);
      let dmg = Math.max(1, Math.round(base));

      const typeMod = typeEffectiveness(move.type, defender.types);
      dmg = Math.round(dmg * typeMod);

      if (defender.debuffs.vulnerability) dmg = Math.round(dmg * 1.2);
      if (defender.shield > 0) dmg = Math.round(dmg * 0.65);
      if (move.effect === 'multi') dmg = Math.round(dmg * 0.5);
      return { dmg: Math.max(1, dmg), typeMod };
    }

    function updateUI() {
      const { player, opponent, active } = battleState || {};
      if (!battleState) return;
      playerName.textContent = player.name;
      opponentName.textContent = opponent.name;
      renderTypeRow(playerTypes, player.types);
      renderTypeRow(opponentTypes, opponent.types);
      playerHP.style.width = `${(player.currentHP / player.stats.hp) * 100}%`;
      opponentHP.style.width = `${(opponent.currentHP / opponent.stats.hp) * 100}%`;
      playerStatus.textContent = `${player.currentHP}/${player.stats.hp} HP`;
      opponentStatus.textContent = `${opponent.currentHP}/${opponent.stats.hp} HP`;
      renderMoves(player);
      toggleMoveButtons(active && player.currentHP > 0 && opponent.currentHP > 0);
    }

    function renderMoves(mon) {
      moveButtons.innerHTML = '';
      mon.moves.forEach((move, idx) => {
        const btn = document.createElement('button');
        btn.className = 'move-btn primary';
        btn.innerHTML = `<strong>${idx + 1}. ${move.name}</strong><span>${move.type} • Power ${move.power}</span>`;
        btn.style.background = `linear-gradient(120deg, ${typeColors[move.type] || '#5fd4ff'}, rgba(255,255,255,0.9))`;
        btn.addEventListener('click', () => handlePlayerMove(move));
        moveButtons.appendChild(btn);
      });
    }

    function toggleMoveButtons(enabled) {
      moveButtons.querySelectorAll('button').forEach(btn => btn.disabled = !enabled);
    }

    // ===== Battle Flow =====
    function handlePlayerMove(move) {
      if (!battleState?.active) return;
      if (battleState.player.currentHP <= 0 || battleState.opponent.currentHP <= 0) return;
      performTurn('player', move);
    }

    function performTurn(actorSide, chosenMove) {
      const attacker = actorSide === 'player' ? battleState.player : battleState.opponent;
      const defender = actorSide === 'player' ? battleState.opponent : battleState.player;
      const speedVariance = Math.random() * 8;
      const playerSpeed = battleState.player.stats.spd + (battleState.player.buffs.spd || 0) - (battleState.player.debuffs.spd || 0) + speedVariance;
      const oppSpeed = battleState.opponent.stats.spd + (battleState.opponent.buffs.spd || 0) - (battleState.opponent.debuffs.spd || 0);
      const playerFirst = playerSpeed >= oppSpeed;

      const sequence = playerFirst ? ['player', 'opponent'] : ['opponent', 'player'];
      if (actorSide === 'player') {
        // Player selected move: lock buttons
        toggleMoveButtons(false);
      }
      sequence.forEach(side => {
        if (!battleState.active) return;
        const acting = side === 'player' ? battleState.player : battleState.opponent;
        const target = side === 'player' ? battleState.opponent : battleState.player;
        const move = side === actorSide ? chosenMove : pickAIMove(acting, target);
        if (acting.currentHP <= 0 || target.currentHP <= 0) return;
        executeMove(acting, target, move, side === 'player');
      });
      updateUI();
      if (battleState.active) toggleMoveButtons(true);
    }

    function executeMove(attacker, defender, move, isPlayer) {
      const attackerUnit = isPlayer ? document.getElementById('player-unit') : document.getElementById('opponent-unit');
      const defenderUnit = isPlayer ? document.getElementById('opponent-unit') : document.getElementById('player-unit');
      attackerUnit.classList.add('attack-anim');
      defenderUnit.classList.add('hit-anim');
      setTimeout(() => attackerUnit.classList.remove('attack-anim'), 350);
      setTimeout(() => defenderUnit.classList.remove('hit-anim'), 350);

      // Support or defensive moves
      if (move.power === 0) {
        applyEffect(attacker, defender, move, true);
        log(`${attacker.name} used ${move.name}!`);
      } else {
        const { dmg, typeMod } = computeDamage(attacker, defender, move);
        applyEffect(attacker, defender, move, false, dmg);
        defender.currentHP = Math.max(0, defender.currentHP - dmg);
        log(`${attacker.name} used ${move.name}!${typeMod > 1 ? ' It\'s super effective!' : typeMod < 1 ? ' It\'s not very effective.' : ''} (${dmg} dmg)`);
        if (defender.currentHP <= 0) {
          handleDefeat(attacker, defender);
        }
      }
      if (!isPlayer) lastEnemyMove = move;
      checkHyperfocus(attacker);
      checkHyperfocus(defender);
    }

    function applyEffect(attacker, defender, move, isSupport, damage = 0) {
      switch (move.effect) {
        case 'vulnerability':
          defender.debuffs.vulnerability = 2;
          log(`${defender.name} is Vulnerable!`);
          break;
        case 'multi':
          // apply third hit total
          const hits = 3;
          let total = damage;
          for (let i = 1; i < hits; i++) {
            const { dmg } = computeDamage(attacker, defender, move);
            defender.currentHP = Math.max(0, defender.currentHP - dmg);
            total += dmg;
          }
          log(`Infinite flurry hits ${hits} times for ${total} total!`);
          if (defender.currentHP <= 0) handleDefeat(attacker, defender);
          break;
        case 'slow':
          defender.debuffs.spd = (defender.debuffs.spd || 0) + 8;
          log(`${defender.name}'s speed is snared.`);
          break;
        case 'inspire':
          if (Math.random() < 0.6) {
            attacker.buffs.int = (attacker.buffs.int || 0) + 10;
            log(`${attacker.name} is Inspired! INT increases.`);
          }
          break;
        case 'copy':
          if (lastEnemyMove) {
            const copied = { ...lastEnemyMove, power: Math.round(lastEnemyMove.power * 1.1) };
            log(`${attacker.name} sketches ${lastEnemyMove.name}!`);
            const { dmg } = computeDamage(attacker, defender, copied);
            defender.currentHP = Math.max(0, defender.currentHP - dmg);
            log(`Copied move hits for ${dmg}.`);
            if (defender.currentHP <= 0) handleDefeat(attacker, defender);
          } else {
            log('No move to copy yet!');
          }
          break;
        case 'shield':
          attacker.shield = 2;
          log('Harmony Shield softens upcoming blows.');
          break;
        case 'soften':
          defender.debuffs.atk = (defender.debuffs.atk || 0) + 8;
          log(`${defender.name}'s attacks soften.`);
          break;
        case 'team_shield':
          attacker.shield = 2;
          log('Family Shield envelopes the arena.');
          break;
        case 'heal_speed':
          const heal = Math.round(attacker.stats.hp * 0.12);
          attacker.currentHP = Math.min(attacker.stats.hp, attacker.currentHP + heal);
          defender.currentHP = Math.min(defender.stats.hp, defender.currentHP + Math.round(defender.stats.hp * 0.08));
          attacker.buffs.spd = (attacker.buffs.spd || 0) + 8;
          log('Schedules synced: both sides recover slightly.');
          break;
        case 'cleanse':
          attacker.debuffs = {};
          attacker.shield = 2;
          log('Calm Presence cleanses ailments and grants resilience.');
          break;
        case 'steady':
          attacker.buffs.focus = (attacker.buffs.focus || 0) + 6;
          break;
        case 'reactive':
          if (lastEnemyMove && Math.random() < 0.7) {
            defender.debuffs.def = (defender.debuffs.def || 0) + 6;
            log('Cross-Examination finds contradictions: DEF reduced.');
          }
          break;
        case 'silence':
          if (Math.random() < 0.35) {
            defender.debuffs.silenced = 1;
            log(`${defender.name} is Silenced and hesitates!`);
          }
          break;
        case 'self_int':
          attacker.buffs.int = (attacker.buffs.int || 0) + 8;
          log(`${attacker.name}'s logic sharpens.`);
          break;
        case 'armor_break':
          defender.debuffs.def = (defender.debuffs.def || 0) + 5;
          log(`${defender.name}'s armor is pressured.`);
          break;
      }

      // decrement shields and vulnerability durations
      if (defender.debuffs.vulnerability) defender.debuffs.vulnerability--;
      if (attacker.shield > 0) attacker.shield--;
    }

    function handleDefeat(attacker, defender) {
      battleState.active = false;
      const winnerMsg = `${attacker.name} wins!`;
      winnerBanner.textContent = winnerMsg;
      winnerBanner.style.display = 'flex';
      log(winnerMsg);
      if (attacker.id === 'endrit') applyCaseWon(attacker);
      toggleMoveButtons(false);
    }

    // ===== AI =====
    function pickAIMove(acting, target) {
      const viable = acting.moves.slice();
      viable.sort((a, b) => (typeEffectiveness(b.type, target.types) - typeEffectiveness(a.type, target.types)) + (Math.random() - 0.5));
      let move = viable[0];
      if (acting.debuffs.silenced && move.power > 0) {
        move = acting.moves.find(m => m.power === 0) || move;
        acting.debuffs.silenced = 0;
      }
      lastEnemyMove = move;
      return move;
    }

    // ===== Event Bindings =====
    startBtn.addEventListener('click', () => {
      resetBattleState();
    });

    window.addEventListener('keydown', (e) => {
      if (!battleState?.active) return;
      const idx = parseInt(e.key, 10) - 1;
      if (idx >= 0 && idx < battleState.player.moves.length) {
        const move = battleState.player.moves[idx];
        handlePlayerMove(move);
      }
    });

    // initial render
    renderCards();
  </script>
</body>
</html>
